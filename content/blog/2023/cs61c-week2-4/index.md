---
title: cs61c-su20 week2, week3, week4总结
date: "2023-06-20"
description: cs61c 2020年夏版本的第二周到第四周的lab以及project等的总结，另外我统计了自己在每个部分所花的时间
---

### week2

week2主要除了第一课是关于浮点数的，其余都是关于RISC-V的，通过这周我了解了
1. RISC-V的相关指令包括赋值、寄存器和内存数据传输、算术逻辑运算、跳转等。
2. 在汇编中的函数调用方式，如何通过操作ra实现跳转返回、calling convention、s, sp, t类的寄存器的使用、caller saved callee saved, prologue, epilogue等相关概念。
3. 汇编转换成机器码的相关规则，6大类指令，32位指令按照field区域划分成func3, func7, rd, src1, src2, opcode等，有些指令的区域被拆的很奇怪主要也是为了降低硬件成本，尽可能的复用已有结构。
#### lab2
1. makefile 那个练习里，我看makefile其实也蛮复杂的教程也很长，本着先解决问题的态度，我把课程里的makefile全部copy了去问chatgpt😳，我发现效果很好，以后有什么代码看不懂的可以直接问他😂
2. 练习1和2都是c的位运算的，注意不要把`&`和`&&`弄混了。
3. 练习3一开始我看不懂题目，不知道这个Linear Feedback Shift Register到底是个什么意思，后来去youtube上看了[这个视频](https://www.youtube.com/watch?v=Ks1pw1X22y4&t=311s)还蛮好懂的，大概就是非最高位进行某些运算得到某值，之后整体右移一位，将上一步计算出来的值写入最高位，通过样不断运算可以得到所有比特位的排列组合，比如4位就可以得到16个结果
#### lab3
主要是熟悉下[venus](https://inst.eecs.berkeley.edu/~cs61c/sp21/resources/venus-reference)工作环境，写一个阶乘以及map的汇编程序，主要是和循环相关的运用。


#### project2
通过汇编写一个`28*28`数字图片的ocr. 不过运算矩阵也就是神经网络的参数都是课程已经给好了，我们实现的就是一些列的运算操作，包括向量点乘、矩阵相乘，另外还有读取以及写入bin文件等。基本还是为了让我们熟悉汇编程序的写法以及如何debug. 我是用vscode写的，插件市场里有risc-v的语法高亮插件可以帮我们检查下是否写了啥不支持的语法，当然写的过程还是和传统语言写法很不一样，特别是寄存器很灵活，经常需要查看这个寄存器当前存了什么值，我是通常在程序开头写好注释，s相关的寄存器里存了什么值。
这个课用了venus这个工具充当模拟器，并且已经开源，web版本可以进行debug，并且查看各个寄存器以及内存各个地址里的值，让我对char的存放方式、endiance以及读写文件有了更直观的了解。
关于debug，首先课程里也提到了基础测试是不够的，自己多写点测试才能保证各个函数本身是没问题的，我最后写classify的时候，才发现之前测试通过的matmux这个写的有问题。函数本身没有问题的时候才能通过检查各个函数的传参来debug. 各个函数内部真的都得靠“自觉”，有一个函数内的我的s2寄存器lw的时候offset有问题，结果后来通过一步步二分才发现这里的问题，感觉编译还是蛮难写的😳
#### week2耗时
1. 视频 12.4h 
2. lab 12.5h
3. project 14h
4. 笔记 9.5h
5. 总计：48.4h
因为看了视频之后然后隔了一段时间才写lab，note就相当于复习并做笔记的时间。

### week3
week3里大致讲了从c代码到实际装载运行的4个过程。
另外讲了底层电路相关的一些知识，可以看到计算机的指令最终被转换成逻辑电路后是什么样子；包括cl, sl, truth table, boolean algebra, flip-flop, clock, fsm等相关概念。
#### lab4
##### exercise1
训练如何debug汇编的，和之前写的练习差不多，在这个练习中只能使用s0, s1, 不过这个也就是麻烦点在调用函数前存下t0, t1, 函数调用完再复原就行了。
有个问题查了蛮久才发现，光看真的很难察觉，还是得借助venus一点点查才发现的，就是我一开始拿到的是node的指针`*node`，内部的array和next都是指针，拿到这两个指针值的地方出了问题。我一开始认为arr和next的指针就是node和node+8. 实际上node和node+8只是地址，实际上要拿到的是地址上的值，这些值也是指针就是了。画个图就比较清晰了～
```c
struct node {
    int *arr;
    int size;
    struct node *next;
};
```
##### exercise2
这个练习比较奇怪，我是搞不清楚它在练啥，我的写法就是计算和-3的偏移，接着在已有的output地址上找到对应的值😳
#### week3耗时
1. 视频 7h
2. 笔记 7h
3. lab 3.5h
4. discussion 1.5h
5. 合计 19h

### week4

#### lab5
lab5主要介绍**Logisim**工具的使用，以及构建一些小逻辑门，包括nand, xor之类的，在编写nand的时候我还特地列了truth table, 试图利用布尔代数来写，结果后来想到nand就是not and就行了😂
FSM那里当然可以通过POS或者SOP方法进行编写，但是也可以利用上课老师讲的那种先观察去掉某一个input看是否影响结果的方法。最后一个rotr将移位特定数值转换为多个移位的复合还蛮巧妙的～
#### lab6
lab6没有测试用例，一个exercise是让我们计算时钟频率，另一个是将exercise1的版本改成pipeline的版本，我这里就是在加法器和乘法器之间加了一个寄存器。虽然结果是对的但没法验证😳

#### project3
##### task1
task1主要是用电路图实现ALU，不过基本上都是直接用现成的元件就可以了，不知道用法的按照任务说明里去reference查看各个元件的作用以及输入输出啥的。
比较麻烦点的是`mulh` ，我自己的做法是根据答案来写😂。两个整数以及一个整数一个一个负数，两个都是负数的时候分开处理。
写的时候利用tunnel可以避免电线很乱
##### task4
除了addi要实现其他的操作指令，感觉难度一下子上来了，R类型那里处理就先卡了下，写代码的人的逻辑经常是if else这样，电路这个通常是很多操作都执行，再利用规则去筛选也就是利用mux, 在这里我利用了一个元件是**bit selector**，可以从一系列bit中筛选出是1的index. 
其他的基本上参考课件基本都能完成，就算有不对的，进入测试的时候也能理解自己是哪里理解有误。这个项目话费了我快20个小时，不过有相当一部分时间其实是翻以前的课件。
总的来说我认为这个作者设置的很好，这是我第一次没有写代码而只是用鼠标拖拉拽弄完一个项目哈哈，对cpu的datapath, control logic以及流水线有了个直观的认识～

#### week4时间统计
1. 视频: 8h26分
2. lab: 5h
3. 笔记: 6h
4. project: 18h44分
5. 总计: 38h10分